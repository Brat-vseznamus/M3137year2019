\chapter{7 сентября}

\section{Лямбда-исчисление}

То, чем мы будем заниматься, можно назвать прикладной матлогикой.

В рамках курса матлогики мы рукомахательно рассмотрели изоморфизм Карри-Ховарда, в этом курсе мы его формализуем. Мы затронем систему типов Хиндли-Милнера \textit{(Haskell)} и язык Arend, основанный на гомотопической теории типов.

\subsection{Определение}

В 20-30х годах XX века Алонзо Чёрчем была создана альтернатива теории множеств как основе математики --- лямбда-исчисление. Основная идея --- выбросить из языка все, кроме вызова функций.

В лямбда исчислении есть три конструкции:
\begin{itemize}
    \item Функция \textit{(абстракция)}: \((\lambda x.A)\)
    \item Применение функции \textit{(аппликация)}: \((A\ B)\)
    \item Переменная \textit{(атом)}: \(x\)
\end{itemize}

Большими буквами начала латинского алфавита мы будем обозначать термы, малыми буквам конца --- переменные. \(\lambda\) жадная, как \(\forall\) и \(\exists\) в исчислении предикатов. Аппликация идёт слева направо, т.е. \(\lambda p.p\ F\ T = \lambda p.((p\ F)\ T)\)

Вычисление происходит с помощью \(\beta\)-редукции, его мы определим позже, общее понимание у нас есть из вводной лекции функционального программирования.

\subsection{Булево исчисление}

Определим булево исчисление в \(\lambda\)-исчислении:
\begin{itemize}
    \item \(T \coloneqq \lambda x.\lambda y.x\) --- истина
    \item \(F \coloneqq \lambda x.\lambda y.y\) --- ложь
    \item \(\mathrm{Not} \coloneqq \lambda p.p\ F\ T\)
\end{itemize}

\begin{align*}
    \mathrm{Not}\ F                 & \to_\beta   \\
    ((\lambda x.\lambda y.y)\ F)\ T & \to_\beta   \\
    (\lambda y.y)\ T                & \to_\beta T \\
\end{align*}

\begin{itemize}
    \item \(\mathrm{And} \coloneqq \lambda a.\lambda b.a\ b\ F\)
\end{itemize}

\(\mathrm{And}\) берёт свой второй аргумент, если первый аргумент истина и ложь иначе.

\(\mathrm{And}\) использует идею \textbf{карринга} --- функция от \(2\) аргументов есть функция от первого аргумента, возвращающая другую функцию от второго аргумента.\footnote{Аналогично для \(n\) аргументов.} Например, в выражении ``\(((+)\ 2)\ 3\)'' \(((+)\ 2)\) это функция, которая прибавляет к своему аргументу \(2\).

\subsection{Числа}

Числа в лямбда-исчислении кодируются \textbf{нумералами Чёрча}. Это только один из способов кодировки, есть и другие. Общая идея --- число \(n\) применяет данную функцию к данному аргументу \(n\) раз.
\begin{itemize}
    \item \(0 = \lambda f.\lambda x.x\)
    \item \(1 = \lambda f.\lambda x.f\ x\)
    \item \(3 = \lambda f.\lambda x.f\ (f\ (f\ x))\)
    \item \(\overline{n + 1} = \lambda f.\lambda x.f (\overline{n}\ f\ x)\)
    \item \(( + 1) = \lambda n.\lambda f.\lambda x.n\ f\ (f\ x)\) --- функция инкремента.
    \item \((+) = \lambda a.\lambda b.b\ ((+)\ \overline{1})\ a\): \(b\) раз прибавляет единицу к \(a\).
    \item \((\cdot) = \lambda a.\lambda b.a\ ((+)\ b)\ \overline{0}\): \(a\) раз прибавляет \(b\) к \(0\).
\end{itemize}

Ходят легенды, что Клини изобрел декремент у зубного врача под действием наркоза. Существует много способов определить декремент различных степеней упоротости.

Рассмотрим декремент, основанный на следующей идее: пусть есть упорядоченная пара \(\ev{a, b}\) и функция \((*) : \ev{a, b} \mapsto \ev{b, b + 1}\). Тогда применив \((*)\) \(n\) раз к \(\ev{0, 0}\) и взяв первый элемент, возьмём первый элемент пары.

Упорядоченная пара определяется следующим способом:
\[\mathrm{MkPair} = \lambda a.\lambda b.(\lambda p.p\ a\ b)\]

Можно потрогать эмулятор лямбда-исчисления \texttt{lci}, будет полезно для домашних заданий.

\subsection{Типизированное лямбда-исчисление}

Лямбда-исчисление для нас будет просто языком программирования. Для начала мы его типизируем, потому что нетипизированное лямбда-исчисление противоречиво.

Пусть у каждого выражения \(A\) есть тип \(\tau\), что обозначается \(A : \tau\). Также используется некоторый контекст с переменными и их типами, обозначаемый \(M\). Все вместе это записывается как \(M \vdash A : \tau\), что напоминает исчисление предикатов.

\subsection{\(Y\)-комбинатор и противоречивость нетипизированного \(\lambda\)-исчисления}

Мы хотим, чтобы \(\to_\beta\) сохраняло значения, т.к. иначе мы вообще не можем говорить о равенстве термов.

\begin{definition}
    \(Y \coloneqq \lambda f.(\lambda x.f\ (x\ x)) (\lambda x.f\ (x\ x))\) --- \(Y\)-комбинатор, для него верно \(Y f \approx f (Y f)\). Такое свойство называется ``быть \textbf{комбинатором неподвижной точки}'', т.е. он находит неподвижную точку функции:  \(A\) такое, что \(f(A) = A\).
\end{definition}

% Что происходит, когда неподвижной точки нет, т.е. чему равно \(Y\ \mathrm{Not}\)?

Пусть мы добавили бинарную операцию \((\supset)\) --- импликацию с некоторыми аксиомами. Оказывается, что доказуемо любое \(A\). Мы это докажем на последующих лекциях.
% \begin{proof}
%     \[Y (\lambda b.A \supset b) \to_\beta A \supset Y(\lambda b.A \supset b)\]
% \end{proof}

\(Y\)-комбинатор полезен тем, что позволяет реализовывать рекурсию.

\begin{example}
    Запишем факториал в неформальном виде:
    \[\mathrm{Fact} = \lambda n.\mathrm{If}\ (\mathrm{IsZero}\ n)\ \overline{1}\ (\mathrm{Fact}\ (n - 1) \cdot n)\]
    На самом деле \(\mathrm{Fact}\) есть неподвижная точка функции
    \[\lambda f.\lambda n.\mathrm{If}\ (\mathrm{IsZero}\ n)\ \overline{1}\ (f\ (n - 1) \cdot n)\]
    по определению неподвижной точки функции. Тогда \(\mathrm{Fact}\) это
    \[Y(\lambda f.\lambda n.\mathrm{If}\ (\mathrm{IsZero}\ n)\ \overline{1}\ (f\ (n - 1) \cdot n))\]
\end{example}

У нас появляется проблема: есть выражения, которым мы не можем приписать значение, например
\[Y(\lambda f.\lambda x.f\ (\mathrm{Not}\ x))\]

Эта проблема происходит из-за того, что наш язык слишком мощный --- мы написали решатель любых уравнений, даже тех, у которых нет решения. Логичный выход из этой ситуации --- запретить то, из-за чего у нас возникают проблемы. Как запретить \(Y\)? Оказывается, это позволяют сделать типы --- они будут делить выражения на добропорядочные и недобропорядочные.

% Правила типизации:
% \begin{itemize}
%     \item \(\Gamma, A : \tau \vdash A : \tau\)
% \end{itemize}
